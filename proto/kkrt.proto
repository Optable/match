syntax = "proto3";

package optable.kkrt.v1;

// The protocol is divided into 3 stages to perform a KKRT Private Set
// Intersection exchange, also known as Batched-OPRF PSI.
//
// Stage 1: Cuckoohash parameters negotiaton
//
// - Receiver 1-1: read identifier, seeds 3 different hash function that hash to 1.2 * |Y|,
//                 and sends a CuckooHashParamSetup
// - Receiver 1-2: cuckoohash Y, and output cuckhash table B, stash S and a map Z that holds
//                 item y as key, and the index of hash function as value.
//
// - Sender 1-1:   reads identifier, and receives a CuckooHashParamSetup
//
// Stage 2: OT + OPRF
//
// - Sender 2-1:   Instantiate pseudorandom code C (AES-128 run 4 times), yet another hash funcon H,
//                 and sample the secret choice bit string s of length k, and
//                 sends an InitKkrtOtParamSetup
//
// - Sender 2-2:   Act as Receiver in KKRT OT extension with input (s_i) for i in [k].
//
// - Sender 2-3:   Receives q^i for i in [k], where q^i in (U^i, T^i) depending on s_i.
// - Sender 2-4:   stores OPRF keys: k_j = (C, s), (j, q_j).
//
// - Receiver 2-1: Receives an InitKkrtOtParamSetup,
//                 Computes OPRF input r: r = y || z(y) if y in B, or r = y, if y in S.
//                 Samples uniformly random m x k matrix U, m=1.2*|Y| + |S|,
//                 Computes m x k matrix T: T_j = C(r_j) ^ U_j for j in [m].
//
// - Receiver 2-2: Ac as Sender in KKRT OT extension with input (U^i, T^i) for i in [k].
// - Receiver 2-3: stores OPRF mask (outputs) F(k_j, r_j) = H(j || U_j) for j in [m]
//
// Stage 3: PSI
//
// - Sender 1-1:   Evaluate OPRF using keys k on input X, output all possible OPRF outputs H_X, S_X,
//                 for x in X:
//                   for i in {1, 2, 3}:
//                       H_X = H_X + H(h_i(x) || C(x || i) * s ^ q[h_i(x)])
//                 for x in X:
//                   for j in {1, 2, ..., |S|}:
//                       S_X = S_X + H(1.2|Y| + j || C(x) * s ^ q[1.2|Y|+j])
//
// - Sender 1-2:   Permute H_X, S_X, send them.
//
// - Receiver 1-1: Compute Intersection by comparing H_X', S_X' with OPRF output F(k, r).


message CuckooHashParamSetup {
    // Number of records from receiver: |Y|
    uint64 receiverSize = 1;
    // stash size |S|
    uint64 stash = 2;
    // param k
    uint64 k = 3;
    // random 16 bytes salt for 3 hash functions
    // see https://pkg.go.dev/golang.org/x/crypto@v0.0.0-20210513164829-c07d793c2f9a/blake2b
    bytes seed1 = 4;
    bytes seed2 = 5;
    bytes seed3 = 6;
}

message InitKkrtOtParamSetup {
    // random 16 bytes seed for linear error correcting code C
    // to instantiate AES-128
    // see https://golang.org/pkg/crypto/aes/
    bytes aesHashingSeed = 1;
    // random 64 bytes salt for hash function to produce OPRF output
    bytes hashSeed = 2;
    // Number of base OT (Naor-Pinkas) to run default:128
    uint64 baseOtCount = 3;
}

// See https://pkg.go.dev/github.com/bwesterb/go-ristretto@v1.2.0/edwards25519#FieldElement
message RistrettoPoint {
    message FieldElement {
        repeated uint64 e = 1; //5 field elements
    }
    // X, Y, Z, T (4 field elements)
    FieldElement X = 1; //x = X/Z
    FieldElement Y = 2; //y = Y/Z
    FieldElement Z = 3;
    FieldElement T = 4; //XY=ZT condition
}

// We will perform Elliptic Curve Naor Pinkas, instead of the Diffie-Hellman style Naor Pinkas
message NaorPinkasBaseOtParamSetup {
    // Assume for now the ristretto point on Curve25519 are represented in bytes
    RistrettoPoint basePoint = 1; // G
    RistrettoPoint pointA = 2; // A=aG
}

message NaorPinkasBaseOtReceiver {
    RistrettoPoint pubKeyZero = 1; // k_0 = bG, or k_0 = A - bG
}

message NaorPinkasBaseOtSender {
    bytes hashSeed = 1; // seed for hash function H
    RistrettoPoint pointR = 2; // R = rG
    bytes encryptedM0 = 3; //E_0 = H(rk_0) ^ m_0
    bytes encryptedM1 = 4; //E_1 = H(rk_1) ^ m_1
}

message KkrtOtSender {
    message Row {
        repeated uint64 hashes = 1 [packed=true];
    }
    repeated Row CorrectionMatrix = 1;
    bytes key = 2; //key to AES to generate internal matrices.
}

message KkrtOtReceiver {
    bytes key = 1; //key to AES to generate internal matrices.
}

message PsiSender {
    message OprfMasks {
        repeated uint64 hashes = 1 [packed=true]; // an array of 3 hashes.
    }

    repeated OprfMasks OprfMasksFromCuckooHashTable= 1; // |x| by 3 2D array
    repeated uint64 OprfMasksFromCuckooHashStash = 2; // |x| by 1 array
}
