syntax = "proto3";

package optable.kkrt.v1;

// The protocol is divided into 3 stages to perform a KKRT Private Set
// Intersection exchange, also known as Batched-OPRF PSI.
//
// Stage 1: Cuckoohash parameters negotiaton
//
// - Receiver 1-1: read identifier, seeds 3 different hash function that hash to 1.2 * |Y|,
//                 and sends a CuckooHashSetup
// - Receiver 1-2: cuckoohash Y, and output cuckhash table B, stash S and a map Z that holds
//                 item y as key, and the index of hash function as value.
//
// - Sender 1-1:   reads identifier, and receives a CuckooHashSetup
//
// Stage 2: OT + OPRF
//
// - Sender 2-1:   Instantiate pseudorandom code C (AES-128 run 4 times):
//                 C(x) = AES(x||1) || AES(x||2) || AES(x||3) || AES(x||4)
//                 instantiate a random oracle represented by a hash funcon H,
//                 and sample the secret choice bit string s of length k, and
//                 sends an KkrtOtSetup message.
//
// - Sender 2-2:   Act as Receiver in KKRT OT extension with input (s_i) for i in [k].
//                 Receives OTSender message to run OTExtension.
//
// - Sender 2-3:   Receives OTExtensionSender message which are the rows q^i for i in [k],
//                 where q^i in (U^i, T^i) depending on s_i.
// - Sender 2-4:   stores OPRF keys: k_j = (C, s), (j, q_j).
//
// - Receiver 2-1: Receives an KkrtOtSetup,
//                 Computes OPRF input r: r = y || z(y) if y in B, or r = y, if y in S.
//                 Samples uniformly random m x k matrix U, m=1.2*|Y| + |S|,
//                 Computes m x k matrix T: T_j = C(r_j) ^ U_j for j in [m].
//
// - Receiver 2-2: Act as Sender in KKRT OT extension with input (U^i, T^i) for i in [k].
//                 Receives OTReceiver message to run the OT extension.
// - Receiver 2-3: stores OPRF mask (outputs) F(k_j, r_j) = H(j || U_j) for j in [m].
//
// Stage 3: PSI
//
// - Sender 3-1:   Evaluate OPRF using keys k on input X, output all possible OPRF outputs H_X, S_X,
//                 for x in X:
//                   for i in {1, 2, 3}:
//                       H_X = H_X + H(h_i(x) || C(x || i) * s ^ q[h_i(x)])
//                 for x in X:
//                   for j in {1, 2, ..., |S|}:
//                       S_X = S_X + H(1.2|Y| + j || C(x) * s ^ q[1.2|Y|+j])
//
// - Sender 3-2:   Permute H_X, S_X, send PsiStage message.
//
// - Receiver 3-1: Compute Intersection by comparing H_X', S_X' with OPRF output F(k, r).


message CuckooHashSetup {
    // Number of records from receiver: |Y|
    uint64 receiver_size = 1;
    // random 16 bytes salt for 3 hash functions
    // see https://pkg.go.dev/golang.org/x/crypto@v0.0.0-20210513164829-c07d793c2f9a/blake2b
    bytes seed1 = 2;
    bytes seed2 = 3;
    bytes seed3 = 4;
    // parameter k for output length of C,
    // # of columns of OT-extension matrices
    // length of secret choice bits s
    uint64 k = 5;
}

message KKRTOtSetup {
    // random 16 bytes seed for linear error correcting code C
    // to instantiate AES-128
    // see https://golang.org/pkg/crypto/aes/
    bytes aes_hashing_seed = 1;
    // random 64 bytes salt for hash function to produce OPRF output
    bytes hash_seed = 2;
    // Number of base OT (Naor-Pinkas) to run default:128
    uint64 base_ot_count = 3;
}

// See https://pkg.go.dev/github.com/bwesterb/go-ristretto@v1.2.0/edwards25519#FieldElement
message RistrettoPoint {
    message FieldElement {
        repeated uint64 e = 1; //5 field elements
    }
    // X, Y, Z, T (4 field elements)
    FieldElement X = 1; //x = X/Z
    FieldElement Y = 2; //y = Y/Z
    FieldElement Z = 3;
    FieldElement T = 4; //XY=ZT condition
}

message EncodedRistrettoPoint {
    bytes point = 1;
}

message OtReceiver {
    repeated RistrettoPoint points = 1;
}

message OtSender {
    bytes hash_seed = 1;
    repeated RistrettoPoint points = 1;
    bytes encrypted_m0 = 3;
    bytes encrypted_m1 = 4;
}

message OtExtensionSender {
    message Row {
        repeated uint64 hashes = 1;
    }
    repeated Row correction_matrices = 1;
    bytes key = 2; //key to AES to generate internal matrices.
}

message OtExtensionReceiver {
    bytes key = 1; //key to AES to generate internal matrices.
}

message PsiStage {
    message OprfMasks {
        repeated uint64 hashes = 1; // an array of 3 hashes.
    }

    repeated OprfMasks oprf_masks_from_cuckoo_hash_tables= 1; // |x| by 3 2D array
    repeated uint64 oprf_masks_from_cuckoo_hash_stashs = 2; // |x| by 1 array
}
